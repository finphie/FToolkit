// <auto-generated/>
// 上記はSA1201誤検知の回避策。（prgma warningは効かない）

using CommunityToolkit.Diagnostics;
using CommunityToolkit.HighPerformance.Buffers;

namespace FToolkit.Extensions;

/// <summary>
/// <see cref="Path"/>クラス関連の拡張メソッドです。
/// </summary>
public static class PathExtensions
{
    const int GuidLength = 32 + 4;
    const string TempExtension = ".tmp";

#pragma warning disable CA1034, CS1591
    extension(Path)
#pragma warning restore CA1034, CS1591
    {
        /// <summary>
        /// 拡張子なしの一時ファイル名を取得します。
        /// </summary>
        /// <returns>拡張子なしの一時ファイル名を返します。</returns>
        public static string GetUniqueTempFileNameWithoutExtension()
            => Guid.NewGuid().ToString();

        /// <summary>
        /// 一時ファイル名を取得します。
        /// </summary>
        /// <returns>一時ファイル名を返します。</returns>
        public static string GetUniqueTempFileName() => GetTempFileNameInternal(TempExtension);

        /// <summary>
        /// 一時ファイル名を取得します。
        /// </summary>
        /// <param name="extension">拡張子</param>
        /// <returns>一時ファイル名を返します。</returns>
        /// <exception cref="ArgumentException">拡張子が空文字または先頭の文字が"."ではありません。</exception>
        /// <exception cref="ArgumentOutOfRangeException">"."を含む拡張子の長さが1以下です。</exception>
        public static string GetUniqueTempFileName(ReadOnlySpan<char> extension)
        {
            Guard.IsInRangeFor(1, extension);
            Guard.IsEqualTo(extension[0], '.');

            return GetTempFileNameInternal(extension);
        }

        /// <summary>
        /// .tmp拡張子の一時ファイルパスを取得します。
        /// </summary>
        /// <returns>.tmp拡張子の一時ファイルパスを返します。</returns>
        public static string GetTempFilePath() => GetTempFilePathInternal(TempExtension);

        /// <summary>
        /// 指定された拡張子の一時ファイルパスを取得します。
        /// </summary>
        /// <param name="extension">拡張子</param>
        /// <returns>指定された拡張子の一時ファイルパスを返します。</returns>
        /// <exception cref="ArgumentException">拡張子が空文字または先頭の文字が"."ではありません。</exception>
        /// <exception cref="ArgumentOutOfRangeException">"."を含む拡張子の長さが1以下です。</exception>
        public static string GetTempFilePath(ReadOnlySpan<char> extension)
        {
            Guard.IsInRangeFor(1, extension);
            Guard.IsEqualTo(extension[0], '.');

            return GetTempFilePathInternal(extension);
        }

        /// <summary>
        /// 指定されたディレクトリを親とする、指定された拡張子の一時ファイルを取得します。
        /// </summary>
        /// <param name="parentDirectoryPath">親ディレクトリのパス</param>
        /// <param name="extension">拡張子</param>
        /// <returns>指定された拡張子の一時ファイルパスを返します。</returns>
        /// <exception cref="ArgumentException">
        /// 親ディレクトリのパスが空文字です。
        /// または、拡張子が空文字または先頭の文字が"."ではありません。
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// 親ディレクトリパスの長さが1未満です。
        /// または、"."を含む拡張子の長さが1以下です。
        /// </exception>
        public static string GetTempFilePath(ReadOnlySpan<char> parentDirectoryPath, ReadOnlySpan<char> extension)
        {
            Guard.IsNotEmpty(parentDirectoryPath);
            Guard.IsInRangeFor(1, extension);
            Guard.IsEqualTo(extension[0], '.');

            using var buffer = SpanOwner<char>.Allocate(GuidLength + extension.Length);
            var destination = buffer.Span;

            GenerateTempFileNameInternal(destination, extension);
            return Path.Join(Path.GetTempPath(), parentDirectoryPath, destination);
        }
    }

    static string GetTempFileNameInternal(ReadOnlySpan<char> extension)
    {
        using var buffer = SpanOwner<char>.Allocate(GuidLength + extension.Length);
        GenerateTempFileNameInternal(buffer.Span, extension);
        return buffer.ToString();
    }

    static string GetTempFilePathInternal(ReadOnlySpan<char> extension)
    {
        using var buffer = SpanOwner<char>.Allocate(GuidLength + extension.Length);
        var destination = buffer.Span;

        GenerateTempFileNameInternal(destination, extension);
        return Path.Join(Path.GetTempPath(), destination);
    }

    static void GenerateTempFileNameInternal(Span<char> destination, ReadOnlySpan<char> extension)
    {
        var guid = Guid.NewGuid();
        guid.TryFormat(destination, out _);
        extension.CopyTo(destination[GuidLength..]);
    }
}
